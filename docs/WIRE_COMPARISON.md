# Wire 对比示例：手动 vs 自动

## 场景：初始化推荐服务

假设我们需要创建一个 `RecommendationHandler`，它的依赖链是：

```
RecommendationHandler
  ↓ 依赖
RecommendationService
  ↓ 依赖
RecommendationGenerator + SocialGraphRepo + ContentRepo + ContentClient + UserRPCClient + ReasonConfigClient
  ↓ 依赖
基础设施（数据库、RPC 客户端等）
```

## 方式 1：手动依赖注入

### main.go（手动方式）

```go
package main

import (
    "log"
    "service/application/service"
    domainService "service/domain/service"
    "service/infrastructure/client"
    "service/infrastructure/repository"
    "service/interface/handler"
)

func main() {
    // 手动初始化所有依赖
    deps := initDependencies()

    // 创建 Handler
    recommendationHandler := handler.NewRecommendationHandler(
        deps.RecommendationService,
    )

    // 启动服务
    // ...
}

// 手动依赖注入函数
func initDependencies() *Dependencies {
    log.Println("Initializing dependencies...")

    // 1. 基础设施层
    userRPCClient := repository.NewMockUserRPCClient()
    var reasonConfigClient service.ReasonTextConfigClient = nil

    // 2. 仓储层
    socialGraphRepo := repository.NewMockSocialGraphRepository()
    contentRepo := repository.NewMockContentRepository()

    // 3. 领域服务层
    generator := domainService.NewRecommendationGenerator(
        socialGraphRepo,
        contentRepo,
    )

    // 4. 应用服务层
    recommendationService := service.NewRecommendationService(
        generator,
        socialGraphRepo,
        contentRepo,
        client.NewContentServiceRPCClient(),
        userRPCClient,
        reasonConfigClient,
    )

    log.Println("Dependencies initialized successfully")

    return &Dependencies{
        RecommendationService: recommendationService,
    }
}

type Dependencies struct {
    RecommendationService *service.RecommendationService
}
```

**代码行数**：约 50 行

**问题**：
1. ❌ 需要手动管理依赖顺序
2. ❌ 添加新依赖需要修改多处
3. ❌ 依赖错误在运行时才发现
4. ❌ 代码冗长，难以维护

## 方式 2：Wire 依赖注入

### wire.go（Wire 配置）

```go
//go:build wireinject
// +build wireinject

package main

import (
    "service/application/service"
    domainService "service/domain/service"
    "service/infrastructure/client"
    "service/infrastructure/repository"
    "service/interface/handler"

    "github.com/google/wire"
)

// 定义 Provider（如何构造对象）
func provideUserRPCClient() service.UserRPCClient {
    return repository.NewMockUserRPCClient()
}

func provideContentServiceClient() service.ContentServiceClient {
    return nil // 使用本地数据库
}

func provideReasonConfigClient() service.ReasonTextConfigClient {
    return nil // 不使用配置服务
}

func provideSocialGraphRepository() repository.SocialGraphRepository {
    return repository.NewMockSocialGraphRepository()
}

func provideContentRepository() repository.ContentRepository {
    return repository.NewMockContentRepository()
}

// 定义 ProviderSet（按层分组）
var infrastructureSet = wire.NewSet(
    provideUserRPCClient,
    provideContentServiceClient,
    provideReasonConfigClient,
)

var repositorySet = wire.NewSet(
    provideSocialGraphRepository,
    provideContentRepository,
)

var domainServiceSet = wire.NewSet(
    domainService.NewRecommendationGenerator,
)

var applicationServiceSet = wire.NewSet(
    service.NewRecommendationService,
)

var handlerSet = wire.NewSet(
    handler.NewRecommendationHandler,
)

// 定义 Injector（需要什么对象）
func InitializeRecommendationHandler() *handler.RecommendationHandler {
    wire.Build(
        infrastructureSet,
        repositorySet,
        domainServiceSet,
        applicationServiceSet,
        handlerSet,
    )
    return nil // Wire 会生成真实实现
}
```

**代码行数**：约 30 行

### main.go（使用 Wire）

```go
package main

import (
    "log"
)

func main() {
    // 使用 Wire 生成的函数（一行代码！）
    recommendationHandler := InitializeRecommendationHandler()

    // 启动服务
    // ...
}
```

**代码行数**：约 5 行

### wire_gen.go（Wire 自动生成）

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate go run github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package main

import (
    "service/application/service"
    domainService "service/domain/service"
    "service/infrastructure/repository"
    "service/interface/handler"
)

// Wire 自动生成的依赖注入代码
func InitializeRecommendationHandler() *handler.RecommendationHandler {
    // 1. 基础设施层
    userRPCClient := provideUserRPCClient()
    contentServiceClient := provideContentServiceClient()
    reasonTextConfigClient := provideReasonConfigClient()

    // 2. 仓储层
    socialGraphRepository := provideSocialGraphRepository()
    contentRepository := provideContentRepository()

    // 3. 领域服务层
    recommendationGenerator := domainService.NewRecommendationGenerator(
        socialGraphRepository,
        contentRepository,
    )

    // 4. 应用服务层
    recommendationService := service.NewRecommendationService(
        recommendationGenerator,
        socialGraphRepository,
        contentRepository,
        contentServiceClient,
        userRPCClient,
        reasonTextConfigClient,
    )

    // 5. 接口层
    recommendationHandler := handler.NewRecommendationHandler(
        recommendationService,
    )

    return recommendationHandler
}
```

**优势**：
1. ✅ Wire 自动管理依赖顺序
2. ✅ 添加新依赖只需添加 Provider
3. ✅ 依赖错误在编译时发现
4. ✅ 代码简洁，易于维护

## 对比总结

### 代码量对比

| 文件 | 手动方式 | Wire 方式 |
|------|---------|----------|
| main.go | 50 行 | 5 行 |
| wire.go | - | 30 行 |
| wire_gen.go | - | 自动生成 |
| **总计（手写）** | **50 行** | **35 行** |

### 添加新依赖

假设我们要添加一个新的依赖：`CacheClient`

#### 手动方式

需要修改 3 处：

```go
// 1. 创建对象
cacheClient := client.NewCacheClient()

// 2. 传递给依赖它的对象
recommendationService := service.NewRecommendationService(
    generator,
    socialGraphRepo,
    contentRepo,
    client.NewContentServiceRPCClient(),
    userRPCClient,
    reasonConfigClient,
    cacheClient, // 新增
)

// 3. 修改构造函数签名
func NewRecommendationService(
    generator *service.RecommendationGenerator,
    socialGraphRepo repository.SocialGraphRepository,
    contentRepo repository.ContentRepository,
    contentClient ContentServiceClient,
    userRPCClient UserRPCClient,
    reasonConfigClient ReasonTextConfigClient,
    cacheClient CacheClient, // 新增
) *RecommendationService {
    // ...
}
```

#### Wire 方式

只需添加 1 个 Provider：

```go
// 1. 添加 Provider
func provideCacheClient() service.CacheClient {
    return client.NewCacheClient()
}

// 2. 添加到 ProviderSet
var infrastructureSet = wire.NewSet(
    provideUserRPCClient,
    provideContentServiceClient,
    provideReasonConfigClient,
    provideCacheClient, // 新增
)

// 3. 修改构造函数签名（这个是必须的）
func NewRecommendationService(
    generator *service.RecommendationGenerator,
    socialGraphRepo repository.SocialGraphRepository,
    contentRepo repository.ContentRepository,
    contentClient ContentServiceClient,
    userRPCClient UserRPCClient,
    reasonConfigClient ReasonTextConfigClient,
    cacheClient CacheClient, // 新增
) *RecommendationService {
    // ...
}

// 4. 运行 wire 重新生成代码
// wire
```

Wire 会自动更新 `wire_gen.go`，添加 `cacheClient` 的创建和传递！

### 错误检查

#### 手动方式：运行时错误

```go
// 忘记创建 userRPCClient
recommendationService := service.NewRecommendationService(
    generator,
    socialGraphRepo,
    contentRepo,
    client.NewContentServiceRPCClient(),
    nil, // 忘记传递！
    reasonConfigClient,
)

// 运行时才发现错误：
// panic: runtime error: invalid memory address or nil pointer dereference
```

#### Wire 方式：编译时错误

```go
// 忘记添加 Provider
var infrastructureSet = wire.NewSet(
    // provideUserRPCClient, // 忘记添加！
    provideContentServiceClient,
    provideReasonConfigClient,
)

// 运行 wire 时立即发现错误：
// wire: service: no provider found for service.UserRPCClient
//   needed by service.NewRecommendationService
//   needed by handler.NewRecommendationHandler
```

### 依赖关系可视化

#### 手动方式

依赖关系隐藏在代码中，需要阅读代码才能理解：

```go
func initDependencies() *Dependencies {
    // 依赖关系不明显
    userRPCClient := repository.NewMockUserRPCClient()
    socialGraphRepo := repository.NewMockSocialGraphRepository()
    contentRepo := repository.NewMockContentRepository()
    generator := domainService.NewRecommendationGenerator(
        socialGraphRepo,
        contentRepo,
    )
    recommendationService := service.NewRecommendationService(
        generator,
        socialGraphRepo,
        contentRepo,
        client.NewContentServiceRPCClient(),
        userRPCClient,
        nil,
    )
    // ...
}
```

#### Wire 方式

依赖关系清晰可见：

```go
// 按层组织，依赖关系一目了然
var infrastructureSet = wire.NewSet(...)
var repositorySet = wire.NewSet(...)
var domainServiceSet = wire.NewSet(...)
var applicationServiceSet = wire.NewSet(...)
var handlerSet = wire.NewSet(...)

func InitializeRecommendationHandler() *handler.RecommendationHandler {
    wire.Build(
        infrastructureSet,      // 最底层
        repositorySet,          // ↑
        domainServiceSet,       // ↑
        applicationServiceSet,  // ↑
        handlerSet,             // 最顶层
    )
    return nil
}
```

## 实际场景对比

### 场景 1：开发环境 vs 生产环境

#### 手动方式

需要写 if-else 判断：

```go
func initDependencies(env string) *Dependencies {
    var userRPCClient service.UserRPCClient

    if env == "production" {
        // 生产环境：使用真实 RPC
        userRPCClient = client.NewUserRPCClient("user-service:8889")
    } else {
        // 开发环境：使用 mock
        userRPCClient = repository.NewMockUserRPCClient()
    }

    // ... 其他依赖
}
```

#### Wire 方式

定义不同的 Injector：

```go
// 开发环境
func InitializeDevelopmentHandler() *handler.RecommendationHandler {
    wire.Build(
        provideMockUserRPCClient,  // mock
        // ... 其他 Provider
    )
    return nil
}

// 生产环境
func InitializeProductionHandler() *handler.RecommendationHandler {
    wire.Build(
        provideRealUserRPCClient,  // 真实 RPC
        // ... 其他 Provider
    )
    return nil
}

// main.go
func main() {
    var handler *handler.RecommendationHandler

    if os.Getenv("ENV") == "production" {
        handler = InitializeProductionHandler()
    } else {
        handler = InitializeDevelopmentHandler()
    }

    // ...
}
```

### 场景 2：单元测试

#### 手动方式

需要手动创建所有 mock：

```go
func TestRecommendationHandler(t *testing.T) {
    // 手动创建所有依赖
    mockUserRPC := &MockUserRPCClient{}
    mockSocialGraphRepo := &MockSocialGraphRepository{}
    mockContentRepo := &MockContentRepository{}

    generator := domainService.NewRecommendationGenerator(
        mockSocialGraphRepo,
        mockContentRepo,
    )

    recommendationService := service.NewRecommendationService(
        generator,
        mockSocialGraphRepo,
        mockContentRepo,
        nil,
        mockUserRPC,
        nil,
    )

    handler := handler.NewRecommendationHandler(recommendationService)

    // 测试逻辑
    // ...
}
```

#### Wire 方式

定义测试专用的 Injector：

```go
// wire_test.go
func InitializeTestHandler() *handler.RecommendationHandler {
    wire.Build(
        provideMockUserRPCClient,
        provideMockSocialGraphRepository,
        provideMockContentRepository,
        wire.Value(service.ContentServiceClient(nil)),
        wire.Value(service.ReasonTextConfigClient(nil)),
        domainServiceSet,
        applicationServiceSet,
        handlerSet,
    )
    return nil
}

// handler_test.go
func TestRecommendationHandler(t *testing.T) {
    // 一行代码创建测试 Handler
    handler := InitializeTestHandler()

    // 测试逻辑
    // ...
}
```

## 总结

### 手动依赖注入

**优点**：
- ✅ 简单直接
- ✅ 无需学习新工具
- ✅ 适合小型项目

**缺点**：
- ❌ 代码冗长
- ❌ 依赖顺序容易出错
- ❌ 运行时才发现错误
- ❌ 难以维护

### Wire 依赖注入

**优点**：
- ✅ 代码简洁
- ✅ 自动解决依赖顺序
- ✅ 编译时检查错误
- ✅ 易于维护
- ✅ 依赖关系清晰

**缺点**：
- ❌ 需要学习 Wire
- ❌ 需要额外的构建步骤（运行 wire 命令）

### 推荐

- **小型项目**（< 10 个依赖）：手动依赖注入
- **中大型项目**（> 10 个依赖）：Wire 依赖注入
- **微服务架构**：Wire 依赖注入
- **团队协作**：Wire 依赖注入

### 迁移建议

如果你已经有手动依赖注入的代码，可以逐步迁移到 Wire：

1. **第一步**：保留现有的 `initDependencies()`
2. **第二步**：创建 `wire.go`，定义 Provider
3. **第三步**：运行 `wire` 生成代码
4. **第四步**：在 main.go 中使用 Wire 生成的函数
5. **第五步**：删除旧的 `initDependencies()`

这样可以平滑过渡，不影响现有功能。
